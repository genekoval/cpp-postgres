#include <commline/commline>
#include <ext/string.h>
#include <filesystem>
#include <fmt/format.h>
#include <fmt/os.h>
#include <fstream>

namespace fs = std::filesystem;

using namespace std::literals;

namespace {
    namespace internal {
        constexpr auto parse_sqlstate =
            "auto parse_sqlstate(std::string_view code)"
            " -> std::optional<sqlstate>"sv;

        struct entry {
            std::string code;
            std::string name;

            auto operator<=>(const entry& other) -> std::weak_ordering {
                return code <=> other.code;
            }
        };

        auto read_token(const char** it, const char* end) -> std::string_view {
            const auto* start = *it;

            while (*it != end && !std::isspace(**it)) ++*it;

            return {start, *it};
        }

        auto skip_whitespace(const char** it, const char* end) -> void {
            while (*it != end && std::isspace(**it)) ++*it;
        }

        auto read(std::istream& stream) -> std::vector<entry> {
            constexpr auto macro_prefix = "ERRCODE_"sv;
            constexpr auto prefix_len = macro_prefix.size();

            auto entries = std::vector<entry>();

            for (std::string line; std::getline(stream, line);) {
                const auto trimmed = ext::trim(line);

                if (trimmed.empty() || trimmed.starts_with('#') ||
                    trimmed.starts_with("Section"))
                    continue;

                auto it = trimmed.begin();
                const auto end = trimmed.end();

                const auto code = read_token(&it, end);
                skip_whitespace(&it, end);
                read_token(&it, end); // Discard E/W/S field
                skip_whitespace(&it, end);
                const auto macro = read_token(&it, end);

                auto name = std::string(macro.substr(prefix_len));

                std::transform(
                    name.begin(),
                    name.end(),
                    name.begin(),
                    [](unsigned char c) -> unsigned char {
                        return std::tolower(c);
                    }
                );

                entries.emplace_back(
                    entry {.code = std::string(code), .name = name}
                );
            }

            return entries;
        }

        auto read(const fs::path& file) -> std::vector<entry> {
            auto stream = std::ifstream(file);
            return read(stream);
        }

        class writer final {
            fmt::ostream stream;
            std::uint8_t level = 0;
        public:
            writer(const fs::path& file) :
                stream(fmt::output_file(file.native())) {}

            auto indent() -> void {
                if (level > 0) stream.print("{: <{}}", "", level * 4);
            }

            auto level_up() -> void { ++level; }

            auto level_down() -> void { --level; }

            auto reset_indent() -> void { level = 0; }

            template <typename... Args>
            auto write(
                fmt::format_string<Args...> format_string,
                Args&&... args
            ) -> void {
                stream.print(format_string, std::forward<Args>(args)...);
            }

            auto writeln() -> void { stream.print("\n"); }

            template <typename... Args>
            auto writeln(
                fmt::format_string<Args...> format_string,
                Args&&... args
            ) -> void {
                indent();
                stream.print(format_string, std::forward<Args>(args)...);
                writeln();
            }

            auto write_header(std::string_view source) -> void {
                writeln("// autogenerated from '{}', do not edit\n", source);
            }

            auto write_include(std::string_view header) -> void {
                writeln("#include <{}>", header);
            }
        };

        auto write_header(
            const fs::path& file,
            std::span<const entry> entries,
            std::string_view source
        ) -> void {
            auto writer = internal::writer(file);

            writer.write_header(source);
            writer.writeln("#pragma once");
            writer.writeln();
            writer.write_include("optional");
            writer.write_include("string_view");
            writer.writeln();
            writer.writeln("namespace pg {{");
            writer.level_up();

            writer.writeln("enum class sqlstate {{");
            writer.level_up();
            {
                auto it = entries.begin();
                const auto end = entries.end();

                while (it != end) {
                    writer.indent();
                    writer.write("{}", it->name);

                    if (++it != end) writer.write(",\n");
                }

                writer.writeln();
            }
            writer.level_down();
            writer.writeln("}};");

            writer.writeln();

            writer.writeln("{};", parse_sqlstate);

            writer.level_down();
            writer.writeln("}}");
        }

        auto write_source(
            const fs::path& file,
            std::span<const entry> entries,
            std::string_view header,
            std::string_view source
        ) -> void {
            constexpr auto include_string = "include/"sv;

            if (header.starts_with(include_string)) {
                header = header.substr(include_string.size());
            }

            auto writer = internal::writer(file);

            writer.write_header(source);
            writer.write_include(header);
            writer.writeln();
            writer.write_include("unordered_map");
            writer.writeln();
            writer.writeln("namespace {{");
            writer.writeln("using enum pg::sqlstate;");
            writer.writeln();
            writer.level_up();
            writer.writeln(
                "const auto map = "
                "std::unordered_map<std::string_view, pg::sqlstate> {{"
            );

            writer.level_up();
            auto it = entries.begin();
            const auto end = entries.end();

            while (it != end) {
                const auto& entry = *it;

                writer.indent();
                writer.write("{{\"{}\", {}}}", entry.code, entry.name);

                if (++it != end) writer.write(",\n");
            }

            writer.writeln();
            writer.level_down();
            writer.writeln("}};");

            writer.level_down();
            writer.writeln("}}");
            writer.writeln();
            writer.writeln("namespace pg {{");
            writer.level_up();

            writer.writeln("{} {{", parse_sqlstate);
            writer.level_up();

            writer.writeln("const auto result = map.find(code);");
            writer.writeln();
            writer.writeln("if (result == map.end()) return std::nullopt;");
            writer.writeln("return result->second;");

            writer.level_down();
            writer.writeln("}}");

            writer.level_down();
            writer.writeln("}}");
        }

        auto errcodes(
            const commline::app& app,
            const fs::path& header,
            const fs::path& source,
            const fs::path& list
        ) -> void {
            auto entries = read(list);

            write_header(header, entries, list.native());
            write_source(source, entries, header.native(), list.native());
        }
    }
}

namespace gen {
    using namespace commline;

    auto errcodes() -> std::unique_ptr<command_node> {
        return command(
            __FUNCTION__,
            "generate header and source files for PostgreSQL error codes",
            options(
                option<fs::path>(
                    {"h", "header"},
                    "Path to the output header (.hpp) file",
                    "path",
                    "errcodes.hpp"
                ),
                option<fs::path>(
                    {"s", "source"},
                    "Path to the output source (.cpp) file",
                    "path",
                    "errcodes.cpp"
                )
            ),
            arguments(required<fs::path>("list")),
            internal::errcodes
        );
    }
}
